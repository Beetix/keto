syntax = "proto3";

package keto.acl.v1;

import "keto/acl/v1/acl.proto";
import "google/api/client.proto";

option go_package = "github.com/ory/keto/api/keto/acl/v1;acl";
option csharp_namespace = "Ory.Keto.Acl.V1";
option java_multiple_files = true;
option java_outer_classname = "CheckServiceProto";
option java_package = "sh.ory.keto.acl.v1";
option php_namespace = "Ory\\Keto\\Acl\\V1";

// The service that performs authorization checks
// based on the stored Access Control Lists.
service CheckService {
  option (google.api.default_host) = "keto.exampleapis.com";
  // Check performs an authorization check.
  rpc Check(CheckRequest) returns (CheckResponse);
}

// The request for a CheckService.Check rpc.
// Checks whether a specific subject is related to an object.
message CheckRequest {
  // The related object in this check.
  Object object = 1;
  // The relation this check.
  string relation = 2;
  // The concrete subject id to check.
  string subject_id = 3;
  // Optional. The staleness bound of this check.
  //
  // It specifies the clients last known snapshot token
  // that the server uses to only check against ACLs newer
  // than specified token snapshot in order to compute the
  // result of this check.
  //
  // Leave this field blank if...
  //  - your application strictly requires to act on up-to-date data
  //  - your application not yet has a snaptoken on the related data (e.g. user)
  //
  // If the specified token is too old, the server tries to fallback and
  // find the best snapshot token to perform the check using least stale
  // ACLs that very likely already got replicated.
  //
  // *It is recommended to perform checks using slightly stale
  // data (e.g. token older than 3-10 seconds) for minimum latency
  // and where the application is allowed to accept slightly off checks.
  bytes snaptoken = 4;
}

// The response for a CheckService.Check rpc.
message CheckResponse {
  // Whether the specified subject (id)
  // is related to the requested object.
  //
  // It is false by default if no ACL matches.
  bool allowed = 1;
  // The last known snapshot token ONLY specified if
  // the request had not specified a snaptoken,
  // since this performed a "content-change request"
  // and consistently fetched the last known snapshot token.
  //
  // This field is not set if the request had specified a snaptoken!
  //
  // If set, clients should cache and use this token
  // for subsequent  requests to have minimal latency,
  // but allow slightly stale responses (only some milliseconds or seconds).
  bytes snaptoken = 2;
}